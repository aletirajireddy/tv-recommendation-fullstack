# GEMINI.md - The AI Architect's Context Module
**Version**: 1.0.0
**Last Updated**: January 2026 (Project Phase: Full-Stack Deployment)

## ðŸ¤– To Future AI Agents
This file serves as your "Context Injection". If you are picking up this project, read this first to understand the *Soul* of the architecture, not just the code.

---

## 1. Core Philosophy: The "Pass-Through" Pattern
**Why isn't the Alert Scanner calling the API directly?**
We deliberately chose a **Pass-Through Architecture** for `alert_scanner.js`.
*   **Context**: TradingView runs scripts in a sandboxed, complex environment. Having multiple scripts firing async network requests to our local API created "Split Brain" issues where Alerts didn't match the Scans.
*   **The Solution**: `alert_scanner.js` is *passive*. It scrapes alerts and buffers them into `unsafeWindow.pendingAlertBatch`.
*   **The Master**: `symbol_market_scanner.js` is the *active* master. When it scans the table, it grabs the buffer from `unsafeWindow`, attaches it to its own payload, and sends a specific "Snapshot" to the DB.
*   **Result**: Every Alert batch is perfectly synchronized with a Market Scan ID (`scan_entries` linked to `pulse_events`). **Do not decouple this unless you move to a cloud-based webhook architecture.**

## 2. Architecture Decision Records (ADR)

### ADR-01: SQLite over MongoDB/Postgres
*   **Decision**: Use `better-sqlite3`.
*   **Reason**: This is a high-frequency, single-user local dashboard. We needed zero-latency writes and zero-configuration setup. The relational nature of `Scan -> Entries` fits SQL perfectly.

### ADR-02: Split Port Deployment (3000/5173)
*   **Decision**: Decouple Backend (3000) and Frontend (5173).
*   **Reason**: Initially, we tried serving static files from Express. It worked but made development slow (rebuilding on every change) and broke client-side routing logic often.
*   **Current State**: PM2 runs two processes. `tv-client` uses `vite preview` for a production-like serving experience without the overhead of Nginx.

### ADR-03: The "Ghost CMD Window" Fix
*   **Problem**: PM2 spawning `npm run start` on Windows caused persistent popup windows.
*   **Fix**: We wrote `client/start_client.js`. It uses `child_process.spawn` to invoke the `vite` binary *directly* via Node, bypassing `npm.cmd` and `cmd.exe`. It explicitly sets `shell: false`. **Preserve this script.**

## 3. Critical Code Paths

### Data Ingestion
*   `scripts/symbol_market_scanner.js` -> `processData()` -> `buildFinalPayload()` -> `GM_xmlhttpRequest` (POST /scan-report)
*   *Watch for*: The `unsafeWindow` interaction. If TradingView changes their variable protection, this bridge breaks.

### Data Processing (Backend)
*   `server/index.js` -> `app.post('/scan-report')`
*   *Logic*: It writes to 4 tables transactionally. `scans`, `market_states`, `scan_entries`, `pulse_events`.
*   *Real-time*: Implements `io.emit('scan-update')` *inside* the POST route.

### Playback Engine (Frontend)
*   `client/src/store/useTimeStore.js`: This is the brain.
*   *Key Concepts*: `activeScan` (The specific data slice currently visible) vs `timeline` (The metadata of all scans). The "DVR" feature works by purely updating `currentIndex` and fetching the unified ID from the server.

## 4. Future Enhancement Roadmap
If you are asked to improve this system, consider these paths:

1.  **Cloud Sync**: moving `dashboard.db` to a Postgres instance on Supabase/Render to allow remote mobile access.
2.  **Alert Webhooks**: Instead of Tampermonkey scraping, integrating properly with TradingView Webhooks (requires Pro plan).
3.  **AI Analysis Layer**: A Python microservice that reads `dashboard.db` and runs deeper pattern recognition (LSTM/Transformer models) on the stored `market_sentiment` arrays.

---
*Generated by Antigravity (Google DeepMind) - Maintenance Session 4346*
